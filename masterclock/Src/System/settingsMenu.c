/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.32                          *
*        Compiled Oct  8 2015, 11:59:02                              *
*        (c) 2015 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END

#include "settingsMenu.h"
#include "guivars.h"
#include "callbacks.h"
#include "backup.h"
#include <stdbool.h>
/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
#define ID_SETTINGSWINDOW   (GUI_ID_USER + 0x00)
#define ID_BLOCKCONTROLS_TEXT   (GUI_ID_USER + 0x1C)
#define ID_BLOCKCONTROLS_VALUE   (GUI_ID_USER + 0x1D)
#define ID_BACKLIGHTOFF_VALUE   (GUI_ID_USER + 0x1E)
#define ID_BACKLIGHTOFF_TEXT   (GUI_ID_USER + 0x1F)
#define ID_DTMFOUTPUT_TEXT   (GUI_ID_USER + 0x20)
#define ID_DTMFTOLINE1_CHECKBOX   (GUI_ID_USER + 0x21)
#define ID_DTMFTOLINE2_CHECKBOX   (GUI_ID_USER + 0x22)
#define ID_DTMFTOLINE3_CHECKBOX   (GUI_ID_USER + 0x23)
#define ID_DTMFTOLINE4_CHECKBOX   (GUI_ID_USER + 0x24)
#define ID_BUTTON_SETTINGS_BACK (GUI_ID_USER + 0x01)

// USER START (Optionally insert additional defines)
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

// USER START (Optionally insert additional static data)
extern GUI_CONST_STORAGE GUI_FONT GUI_FontArial18;
extern MasterClock masterClock;
// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
	{ WINDOW_CreateIndirect, "Window", ID_SETTINGSWINDOW, 0, 0, 320, 240, 0, 0x0, 0 },
	{ TEXT_CreateIndirect, "Блокировка экрана", ID_BLOCKCONTROLS_TEXT, 1, 5, 150, 20, 0, 0x0, 0 },
	{ DROPDOWN_CreateIndirect, "blockControlsValue", ID_BLOCKCONTROLS_VALUE, 150, 5, 80, 25, 0, 0x0, 0 },
	//{ DROPDOWN_CreateIndirect, "Dropdown", ID_BACKLIGHTOFF_VALUE, 105, 30, 55, 18, 0, 0x0, 0 },
	//{ TEXT_CreateIndirect, "Гашение экрана", ID_BACKLIGHTOFF_TEXT, 1, 30, 100, 20, 0, 0x0, 0 },
	{ TEXT_CreateIndirect, "DTMF сигнал в линию", ID_DTMFOUTPUT_TEXT, 1, 100, 200, 20, 0, 0x0, 0 },
	{ CHECKBOX_CreateIndirect, "sendDTMF_toLine1", ID_DTMFTOLINE1_CHECKBOX, 95, 120, 35, 20, 0, 0x0, 0 },
	{ CHECKBOX_CreateIndirect, "sendDTMF_toLine2", ID_DTMFTOLINE2_CHECKBOX, 135, 120, 35, 20, 0, 0x0, 0 },
	{ CHECKBOX_CreateIndirect, "sendDTMF_toLine3", ID_DTMFTOLINE3_CHECKBOX, 175, 120, 35, 20, 0, 0x0, 0 },
	{ CHECKBOX_CreateIndirect, "sendDTMF_toLine4", ID_DTMFTOLINE4_CHECKBOX, 215, 120, 35, 20, 0, 0x0, 0 },
	{ BUTTON_CreateIndirect, "Назад", ID_BUTTON_SETTINGS_BACK, 245, 165, 70, 70, 0, 0x0, 0 },
	// USER START (Optionally insert additional widgets)
	// USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

// USER START (Optionally insert additional static code)
// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialog(WM_MESSAGE * pMsg) {
	WM_HWIN hItem;
	int     NCode;
	int     Id;
	uint16_t i = 0;
	uint8_t j = 0;
	uint8_t state;
	// USER START (Optionally insert additional variables)
	// USER END

	switch(pMsg->MsgId) {
	case WM_INIT_DIALOG:

		hItem = pMsg->hWin;
		WINDOW_SetBkColor(hItem, 0x191615);
		//
		// Initialization of 'blockControlsValue'
		//
		hItem = WM_GetDialogItem(pMsg->hWin, ID_BLOCKCONTROLS_TEXT);
		

		hItem = WM_GetDialogItem(pMsg->hWin, ID_BLOCKCONTROLS_VALUE);
		DROPDOWN_AddString(hItem, "Выкл");
		DROPDOWN_AddString(hItem, "1 мин");
		DROPDOWN_AddString(hItem, "5 мин");
		DROPDOWN_AddString(hItem, "10 мин");
		
		DROPDOWN_SetListHeight(hItem, 80);
		switch (masterClock.guiVars->lockCountDownInitial)
		{
		case 0:
			DROPDOWN_SetSel(hItem, 0);
			break;
		case 60:
			DROPDOWN_SetSel(hItem, 1);
			break;
		case 300:
			DROPDOWN_SetSel(hItem, 2);
			break;
		case 600:
			DROPDOWN_SetSel(hItem, 3);
			break;
		}
		
		for (i = ID_DTMFTOLINE1_CHECKBOX, j = 0; i <= ID_DTMFTOLINE4_CHECKBOX; i++, j++)
		{
			hItem = WM_GetDialogItem(pMsg->hWin, i);
			CHECKBOX_SetTextColor(hItem, GUI_WHITE);
			if (masterClock.line[j].DTMFon) 
			{
				CHECKBOX_Check(hItem);
			}
			else
			{
				CHECKBOX_Uncheck(hItem);
			}
		}
		
		//
		// Initialization of 'Dropdown'
		//
//		hItem = WM_GetDialogItem(pMsg->hWin, ID_BACKLIGHTOFF_VALUE);
//		DROPDOWN_AddString(hItem, "Выкл");
//		DROPDOWN_AddString(hItem, "1 мин");
//		DROPDOWN_AddString(hItem, "5 мин");
//		DROPDOWN_AddString(hItem, "10 мин");
		
//		DROPDOWN_SetTextColor(hItem, 0, GUI_WHITE);
//		DROPDOWN_SetTextColor(hItem, 1, GUI_WHITE);
//		DROPDOWN_SetTextColor(hItem, 2, GUI_WHITE);
//		DROPDOWN_SetTextColor(hItem, 3, GUI_WHITE);
		//
		// Initialization of 'sendDTMF_toLine1'
		//
		hItem = WM_GetDialogItem(pMsg->hWin, ID_DTMFTOLINE1_CHECKBOX);
		CHECKBOX_SetText(hItem, "1");
		//
		// Initialization of 'sendDTMF_toLine2'
		//
		hItem = WM_GetDialogItem(pMsg->hWin, ID_DTMFTOLINE2_CHECKBOX);
		CHECKBOX_SetText(hItem, "2");
		//
		// Initialization of 'sendDTMF_toLine3'
		//
		hItem = WM_GetDialogItem(pMsg->hWin, ID_DTMFTOLINE3_CHECKBOX);
		CHECKBOX_SetText(hItem, "3");
		//
		// Initialization of 'sendDTMF_toLine4'
		//
		hItem = WM_GetDialogItem(pMsg->hWin, ID_DTMFTOLINE4_CHECKBOX);
		CHECKBOX_SetText(hItem, "4");
		// USER START (Optionally insert additional code for further widget initialization)
		// USER END
		break;
	case WM_NOTIFY_PARENT:
		Id    = WM_GetId(pMsg->hWinSrc);
		NCode = pMsg->Data.v;
		switch (Id) {
		case ID_BLOCKCONTROLS_VALUE: // Notifications sent by 'blockControlsValue'
		  switch(NCode) {
			case WM_NOTIFICATION_CLICKED:
				// USER START (Optionally insert code for reacting on notification message)
				// USER END
				break;
			case WM_NOTIFICATION_RELEASED:
				// USER START (Optionally insert code for reacting on notification message)
				// USER END
				break;
			case WM_NOTIFICATION_SEL_CHANGED:
				// USER START (Optionally insert code for reacting on notification message)
			  state = DROPDOWN_GetSel(WM_GetDialogItem(pMsg->hWin, Id));
				switch (state)
				{
				case 0:
					masterClock.guiVars->lockCountDownInitial = 0;
					break;
				case 1:
					masterClock.guiVars->lockCountDownInitial = 60;
					break;
				case 2:
					masterClock.guiVars->lockCountDownInitial = 60 * 5;
					break;
				case 3:
					masterClock.guiVars->lockCountDownInitial = 60 * 10;
					break;	  
				}
				masterClock.guiVars->lockCountDown = masterClock.guiVars->lockCountDownInitial;
				saveSettingsToBKP();
			 
				// USER END
				break;
				// USER START (Optionally insert additional code for further notification handling)
				// USER END
			}
			break;
			//		case ID_BACKLIGHTOFF_VALUE: // Notifications sent by 'Dropdown'
			//		  switch(NCode) {
			//			case WM_NOTIFICATION_CLICKED:
			//				// USER START (Optionally insert code for reacting on notification message)
			//				// USER END
			//				break;
			//			case WM_NOTIFICATION_RELEASED:
			//				// USER START (Optionally insert code for reacting on notification message)
			//				// USER END
			//				break;
			//			case WM_NOTIFICATION_SEL_CHANGED:
			//				// USER START (Optionally insert code for reacting on notification message)
			//				// USER END
			//				break;
			//				// USER START (Optionally insert additional code for further notification handling)
			//				// USER END
			//			}
			//			break;
		case ID_DTMFTOLINE1_CHECKBOX :                   // Notifications sent by 'sendDTMF_toLine1'
			switch(NCode) {
			case WM_NOTIFICATION_CLICKED:
				// USER START (Optionally insert code for reacting on notification message)
				// USER END
				break;
			case WM_NOTIFICATION_RELEASED:
				// USER START (Optionally insert code for reacting on notification message)
				// USER END
				break;
			case WM_NOTIFICATION_VALUE_CHANGED:
				// USER START (Optionally insert code for reacting on notification message)
				masterClock.line[0].DTMFon = CHECKBOX_IsChecked(WM_GetDialogItem(pMsg->hWin, Id));
				saveSettingsToBKP();
				// USER END
				break;
				// USER START (Optionally insert additional code for further notification handling)
				// USER END
			}
			break;
		case ID_DTMFTOLINE2_CHECKBOX: // Notifications sent by 'sendDTMF_toLine2'
		  switch(NCode) {
			case WM_NOTIFICATION_CLICKED:
				// USER START (Optionally insert code for reacting on notification message)
				// USER END
				break;
			case WM_NOTIFICATION_RELEASED:
				// USER START (Optionally insert code for reacting on notification message)
				// USER END
				break;
			case WM_NOTIFICATION_VALUE_CHANGED:
				// USER START (Optionally insert code for reacting on notification message)
				masterClock.line[1].DTMFon = CHECKBOX_IsChecked(WM_GetDialogItem(pMsg->hWin, Id));
				saveSettingsToBKP();
				// USER END
				break;
				// USER START (Optionally insert additional code for further notification handling)
				// USER END
			}
			break;
		case ID_DTMFTOLINE3_CHECKBOX: // Notifications sent by 'sendDTMF_toLine3'
		  switch(NCode) {
			case WM_NOTIFICATION_CLICKED:
				// USER START (Optionally insert code for reacting on notification message)
				// USER END
				break;
			case WM_NOTIFICATION_RELEASED:
				// USER START (Optionally insert code for reacting on notification message)
				// USER END
				break;
			case WM_NOTIFICATION_VALUE_CHANGED:
				// USER START (Optionally insert code for reacting on notification message)
				masterClock.line[2].DTMFon = CHECKBOX_IsChecked(WM_GetDialogItem(pMsg->hWin, Id));
				saveSettingsToBKP();
				// USER END
				break;
				// USER START (Optionally insert additional code for further notification handling)
				// USER END
			}
			break;
		case ID_DTMFTOLINE4_CHECKBOX: // Notifications sent by 'sendDTMF_toLine4'
		  switch(NCode) {
			case WM_NOTIFICATION_CLICKED:
				// USER START (Optionally insert code for reacting on notification message)
				// USER END
				break;
			case WM_NOTIFICATION_RELEASED:
				// USER START (Optionally insert code for reacting on notification message)
				// USER END
				break;
			case WM_NOTIFICATION_VALUE_CHANGED:
				// USER START (Optionally insert code for reacting on notification message)
				masterClock.line[3].DTMFon = CHECKBOX_IsChecked(WM_GetDialogItem(pMsg->hWin, Id));
				saveSettingsToBKP();
				// USER END
				break;
				// USER START (Optionally insert additional code for further notification handling)
				// USER END
			}
			break;
		case ID_BUTTON_SETTINGS_BACK: // Notifications sent by 'Back'
		switch(NCode) {
			case WM_NOTIFICATION_CLICKED:
				// USER START (Optionally insert code for reacting on notification message)
				// USER END
				break;
			case WM_NOTIFICATION_RELEASED:
				// USER START (Optionally insert code for reacting on notification message)
					returnToMainMenu(&masterClock.handles->hSettingsMenu);
				// USER END
				break;
				// USER START (Optionally insert additional code for further notification handling)
				// USER END
			}
			break;
			// USER START (Optionally insert additional code for further Ids)
			// USER END
		}
		break;
		// USER START (Optionally insert additional message handling)
		// USER END
		default :
		  WM_DefaultProc(pMsg);
		break;
	}
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateWindow
*/
WM_HWIN CreateSettingsWindow(void);
WM_HWIN CreateSettingsWindow(void) {
	WM_HWIN hWin;
	TEXT_SetDefaultFont(&GUI_FontArial18);
	TEXT_SetDefaultTextColor(GUI_WHITE);
	DROPDOWN_SetDefaultFont(&GUI_FontArial18);
	hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
	masterClock.handles->hSettingsMenu = hWin;
	return hWin;
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
