/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.32                          *
*        Compiled Oct  8 2015, 11:59:02                              *
*        (c) 2015 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END

#include "TimeSetup.h"
#include "guivars.h"
#include "string.h"
#include "stdio.h"
#include "stm32f4xx_hal.h"
#include "cmsis_os.h"
#include "TimeCalibrate.h"
#include "callbacks.h"
#include "TimeDateSetup.h"
#include "lines.h"
#include <stdbool.h>
extern RTC_HandleTypeDef hrtc;

extern RTC_TimeTypeDef sTime;
extern RTC_DateTypeDef sDate;

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/



// USER START (Optionally insert additional defines)
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

// USER START (Optionally insert additional static data)

WM_MESSAGE message;
char time[3];
RTC_TimeTypeDef sTime_tmp;
// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
	{ WINDOW_CreateIndirect, "Window", ID_WINDOW_TIMESETUP, 1, -3, 320, 240, 0, 0x0, 0 },
	{ BUTTON_CreateIndirect, "", ID_BUTTON_HOURplus, 5, 85, 70, 70, 0, 0x0, 0 },
	{ HEADER_CreateIndirect, "Header", ID_HEADER_HMS, 0, 20, 240, 30, 0, 0x0, 0 },
	{ HEADER_CreateIndirect, "Header", ID_HEADER_HMS_VALUE, 0, 50, 240, 30, 0, 0x0, 0 },
	{ BUTTON_CreateIndirect, "", ID_BUTTON_MINplus, 85, 85, 70, 70, 0, 0x0, 0 },
	{ BUTTON_CreateIndirect, "", ID_BUTTON_SECplus, 165, 85, 70, 70, 0, 0x0, 0 },
	{ BUTTON_CreateIndirect, "Ввод", ID_BUTTON_ENTER, 245, 85, 70, 70, 0, 0x0, 0 },
	{ BUTTON_CreateIndirect, "Калибр.", ID_BUTTON_CALIBRATE, 245, 5, 70, 30, 0, 0x0, 0 },
	{ BUTTON_CreateIndirect, "Дата", ID_BUTTON_DATE, 245, 45, 70, 30, 0, 0x0, 0 },
	{ BUTTON_CreateIndirect, "", ID_BUTTON_HOURminus, 5, 165, 70, 70, 0, 0x0, 0 },
	{ BUTTON_CreateIndirect, "", ID_BUTTON_MINminus, 85, 165, 70, 70, 0, 0x0, 0 },
	{ BUTTON_CreateIndirect, "", ID_BUTTON_SECminus, 165, 165, 70, 70, 0, 0x0, 0 },
	{ BUTTON_CreateIndirect, "Назад", ID_BUTTON_BACK, 245, 165, 70, 70, 0, 0x0, 0 },
	{ HEADER_CreateIndirect, "Header", ID_HEADER_WINDOW_TIMESETUP, 0, 0, 240, 20, 0, 0x0, 0 },
	// USER START (Optionally insert additional widgets)
	// USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

// USER START (Optionally insert additional static code)
// USER END

/*********************************************************************
*
*       _cbDialog
*/

static void _cbDialog(WM_MESSAGE * pMsg) {
	WM_HWIN hItem;
	int     NCode;
	int     Id;
	uint8_t valsChangedOld = false;
	// USER START (Optionally insert additional variables)
	// USER END

	switch(pMsg->MsgId) {
	case WM_INIT_DIALOG:
		hItem = pMsg->hWin;
		WINDOW_SetBkColor(hItem, 0x191615);
		sTime_tmp = sTime;

		//
		// Initialization of 'Header'
		//
		hItem = WM_GetDialogItem(pMsg->hWin, ID_HEADER_HMS);
		HEADER_AddItem(hItem, 80, "ЧАС", 14);
		HEADER_AddItem(hItem, 80, "МИН", 14);
		HEADER_AddItem(hItem, 80, "СЕК", 14);
		HEADER_SetTextColor(hItem, GUI_WHITE);
		//
		// Initialization of 'Header'
		//
		hItem = WM_GetDialogItem(pMsg->hWin, ID_HEADER_HMS_VALUE);
		HEADER_AddItem(hItem, 80, "18", 14);
		HEADER_AddItem(hItem, 80, "43", 14);
		HEADER_AddItem(hItem, 80, "54", 14);
		masterClock.handles->hHeaderTimeSetupVals = hItem;
		sprintf(time, "%02d", sTime.Hours);
		HEADER_SetItemText(masterClock.handles->hHeaderTimeSetupVals, 0, time);
		sprintf(time, "%02d", sTime.Minutes);
		HEADER_SetItemText(masterClock.handles->hHeaderTimeSetupVals, 1, time);
		sprintf(time, "%02d", sTime.Seconds);
		HEADER_SetItemText(masterClock.handles->hHeaderTimeSetupVals, 2, time);
		HEADER_SetTextColor(masterClock.handles->hHeaderTimeSetupVals, GUI_WHITE);
		//
		// Initialization of 'Header'
		//
		hItem = WM_GetDialogItem(pMsg->hWin, ID_HEADER_WINDOW_TIMESETUP);
		HEADER_AddItem(hItem, 240, "Установка текущего времени", 14);
		HEADER_SetTextColor(hItem, GUI_WHITE);
		// USER START (Optionally insert additional code for further widget initialization)
		// USER END
		break;
	case WM_SEC_UPDATE:
		if (masterClock.guiVars->timeFrozen == 0)
		{
			sprintf(time, "%02d", sTime.Seconds);
			HEADER_SetItemText(masterClock.handles->hHeaderTimeSetupVals, 2, time);
			if (masterClock.guiVars->prevSecond_H == 5 && masterClock.guiVars->prevSecond_L == 9) //прошла минута
				{
					sprintf(time, "%02d", sTime.Hours);
					HEADER_SetItemText(masterClock.handles->hHeaderTimeSetupVals, 0, time);
					sprintf(time, "%02d", sTime.Minutes);
					HEADER_SetItemText(masterClock.handles->hHeaderTimeSetupVals, 1, time);

				}
			HEADER_SetTextColor(masterClock.handles->hHeaderTimeSetupVals, GUI_WHITE);
			pMsg->MsgId = 0;
			masterClock.guiVars->prevSecond_L = sTime.Seconds % 10;
			masterClock.guiVars->prevSecond_H = sTime.Seconds / 10;
			sTime_tmp = sTime;
		}
		break;
	case WM_NOTIFY_PARENT:
		Id = WM_GetId(pMsg->hWinSrc);
		NCode = pMsg->Data.v;
		switch (Id) {
		case ID_BUTTON_HOURplus: // Notifications sent by 'h+'
			switch(NCode) {
			case WM_NOTIFICATION_CLICKED:
				// USER START (Optionally insert code for reacting on notification message)
				masterClock.guiVars->timeFrozen = 1;
				if (sTime_tmp.Hours != 23)
				{
					pollButton(ID_BUTTON_HOURplus, WM_NOTIFICATION_CLICKED, (int8_t*)&sTime_tmp.Hours);
				}
				else
				{
					masterClock.longPressCNT->value = 23;
				}
				if (valsChangedOld != masterClock.guiVars->valsChanged)
				{
					WM_Invalidate(WM_GetDialogItem(pMsg->hWin, ID_BUTTON_ENTER));
				}
				// USER END
				break;
			case WM_NOTIFICATION_RELEASED:
				// USER START (Optionally insert code for reacting on notification message)

				pollButton(ID_BUTTON_HOURplus, WM_NOTIFICATION_RELEASED, (int8_t*)&sTime_tmp.Hours);

				// USER END
				break;
				// USER START (Optionally insert additional code for further notification handling)
				// USER END
			}
			break;


		case ID_BUTTON_MINplus: // Notifications sent by 'm+'
			switch(NCode) {
			case WM_NOTIFICATION_CLICKED:
				// USER START (Optionally insert code for reacting on notification message)
				masterClock.guiVars->timeFrozen = 1;
				if (sTime_tmp.Minutes != 59)
				{
					pollButton(ID_BUTTON_MINplus, WM_NOTIFICATION_CLICKED, (int8_t*)&sTime_tmp.Minutes);
				}
				else
				{
					masterClock.longPressCNT->value = 59;
				}
				if (valsChangedOld != masterClock.guiVars->valsChanged)
				{
					WM_Invalidate(WM_GetDialogItem(pMsg->hWin, ID_BUTTON_ENTER));
				}
				// USER END
				break;
			case WM_NOTIFICATION_RELEASED:
				// USER START (Optionally insert code for reacting on notification message)
				pollButton(ID_BUTTON_MINplus, WM_NOTIFICATION_RELEASED, (int8_t*)&sTime_tmp.Minutes);
				// USER END
				break;
				// USER START (Optionally insert additional code for further notification handling)
				// USER END
			}
			break;
		case ID_BUTTON_SECplus: // Notifications sent by 's+'
			switch(NCode) {
			case WM_NOTIFICATION_CLICKED:
				// USER START (Optionally insert code for reacting on notification message)
				masterClock.guiVars->timeFrozen = 1;
				if (sTime_tmp.Seconds != 59)
				{
					pollButton(ID_BUTTON_SECplus, WM_NOTIFICATION_CLICKED, (int8_t*)&sTime_tmp.Seconds);
				}
				else
				{
					masterClock.longPressCNT->value = 59;
				}
				if (valsChangedOld != masterClock.guiVars->valsChanged)
				{
					WM_Invalidate(WM_GetDialogItem(pMsg->hWin, ID_BUTTON_ENTER));
				}
				// USER END
				break;
			case WM_NOTIFICATION_RELEASED:
				// USER START (Optionally insert code for reacting on notification message)
				pollButton(ID_BUTTON_SECplus, WM_NOTIFICATION_RELEASED, (int8_t*)&sTime_tmp.Seconds);

				// USER END
				break;
				// USER START (Optionally insert additional code for further notification handling)
				// USER END
			}
			break;
		case ID_BUTTON_ENTER: // Notifications sent by 'Enter'
			switch(NCode) {
			case WM_NOTIFICATION_CLICKED:
				// USER START (Optionally insert code for reacting on notification message)
				// USER END
				break;
			case WM_NOTIFICATION_RELEASED:
				// USER START (Optionally insert code for reacting on notification message)
				masterClock.guiVars->timeFrozen = 0;
				masterClock.guiVars->valsChanged = false;
				sTime = sTime_tmp;
				if (HAL_RTC_SetTime(&hrtc, &sTime_tmp, RTC_FORMAT_BIN) != HAL_OK)
				{
					while (1)
					{
						masterClock.guiVars->timeFrozen = 0;
					}
				}
				//pollLinesOutput(10);
				// USER END
				break;
				// USER START (Optionally insert additional code for further notification handling)
				// USER END
			}
			break;
		case ID_BUTTON_CALIBRATE: // Notifications sent by 'Calibrate'
			switch(NCode) {
			case WM_NOTIFICATION_CLICKED:
				// USER START (Optionally insert code for reacting on notification message)
				// USER END
				break;
			case WM_NOTIFICATION_RELEASED:
				// USER START (Optionally insert code for reacting on notification message)
				masterClock.guiVars->timeFrozen = 0;
				masterClock.guiVars->menuState = MENU_STATE_TIMECALIBRATION;
				masterClock.guiVars->valsChanged = false;
				CreateTimeCalibrateWindow();
				WM_DeleteWindow(pMsg->hWin);
				// USER END
				break;
				// USER START (Optionally insert additional code for further notification handling)
				// USER END
			}
			break;
		case ID_BUTTON_DATE: // Notifications sent by 'Date'
			switch(NCode) {
			case WM_NOTIFICATION_CLICKED:
				// USER START (Optionally insert code for reacting on notification message)
				// USER END
				break;
			case WM_NOTIFICATION_RELEASED:
				// USER START (Optionally insert code for reacting on notification message)
				masterClock.guiVars->timeFrozen = 0;
				masterClock.guiVars->menuState = MENU_STATE_TIMEDATESETUP;
				masterClock.guiVars->valsChanged = false;
				CreateTimeDateWindow();
				WM_DeleteWindow(pMsg->hWin);
				// USER END
				break;
				// USER START (Optionally insert additional code for further notification handling)
				// USER END
			}
			break;
		case ID_BUTTON_HOURminus: // Notifications sent by 'h-'
			switch(NCode) {
			case WM_NOTIFICATION_CLICKED:
				// USER START (Optionally insert code for reacting on notification message)
				masterClock.guiVars->timeFrozen = 1;
				if (sTime_tmp.Hours != 0)
				{
					pollButton(ID_BUTTON_HOURminus, WM_NOTIFICATION_CLICKED, (int8_t*)&sTime_tmp.Hours);
				}
				if (valsChangedOld != masterClock.guiVars->valsChanged)
				{
					WM_Invalidate(WM_GetDialogItem(pMsg->hWin, ID_BUTTON_ENTER));
				}
				// USER END
				break;
			case WM_NOTIFICATION_RELEASED:
				// USER START (Optionally insert code for reacting on notification message)
				pollButton(ID_BUTTON_HOURminus, WM_NOTIFICATION_RELEASED, (int8_t*)&sTime_tmp.Hours);
				// USER END
				break;
				// USER START (Optionally insert additional code for further notification handling)
				// USER END
			}
			break;
		case ID_BUTTON_MINminus: // Notifications sent by 'm-'
			switch(NCode) {
			case WM_NOTIFICATION_CLICKED:
				// USER START (Optionally insert code for reacting on notification message)
				masterClock.guiVars->timeFrozen = 1;
				if (sTime_tmp.Minutes != 0)
				{
					pollButton(ID_BUTTON_MINminus, WM_NOTIFICATION_CLICKED, (int8_t*)&sTime_tmp.Minutes);
				}
				if (valsChangedOld != masterClock.guiVars->valsChanged)
				{
					WM_Invalidate(WM_GetDialogItem(pMsg->hWin, ID_BUTTON_ENTER));
				}
				// USER END
				break;
			case WM_NOTIFICATION_RELEASED:
				// USER START (Optionally insert code for reacting on notification message)
				pollButton(ID_BUTTON_MINminus, WM_NOTIFICATION_RELEASED, (int8_t*)&sTime_tmp.Minutes);

				// USER END
				break;
				// USER START (Optionally insert additional code for further notification handling)
				// USER END
			}
			break;
		case ID_BUTTON_SECminus: // Notifications sent by 's-'
			switch(NCode) {
			case WM_NOTIFICATION_CLICKED:
				// USER START (Optionally insert code for reacting on notification message)
				masterClock.guiVars->timeFrozen = 1;
				if (sTime_tmp.Seconds != 0)
				{
					pollButton(ID_BUTTON_SECminus, WM_NOTIFICATION_CLICKED, (int8_t*)&sTime_tmp.Seconds);
				}
				if (valsChangedOld != masterClock.guiVars->valsChanged)
				{
					WM_Invalidate(WM_GetDialogItem(pMsg->hWin, ID_BUTTON_ENTER));
				}
				// USER END
				break;
			case WM_NOTIFICATION_RELEASED:
				// USER START (Optionally insert code for reacting on notification message)
				pollButton(ID_BUTTON_SECminus, WM_NOTIFICATION_RELEASED, (int8_t*)&sTime_tmp.Seconds);
				// USER END
				break;
				// USER START (Optionally insert additional code for further notification handling)
				// USER END
			}
			break;
		case ID_BUTTON_BACK: // Notifications sent by 'Back'
			switch(NCode) {
			case WM_NOTIFICATION_CLICKED:
				// USER START (Optionally insert code for reacting on notification message)
				// USER END
				break;
			case WM_NOTIFICATION_RELEASED:
				// USER START (Optionally insert code for reacting on notification message)
				masterClock.guiVars->timeFrozen = 0;
				message.MsgId = WM_BACKTOMAINMENU;
				message.Data.v = 0xFF;
				masterClock.guiVars->valsChanged = false;
				WM_SendMessage(masterClock.handles->hMainMenu, &message);

				WM_DeleteWindow(pMsg->hWin);
				// USER END
				break;
				// USER START (Optionally insert additional code for further notification handling)
				// USER END
			}
			break;
		case ID_HEADER_WINDOW_TIMESETUP: // Notifications sent by 'Header'
			switch(NCode) {
			case WM_NOTIFICATION_CLICKED:
				// USER START (Optionally insert code for reacting on notification message)
				// USER END
				break;
			case WM_NOTIFICATION_RELEASED:
				// USER START (Optionally insert code for reacting on notification message)
				// USER END
				break;
			case WM_NOTIFICATION_MOVED_OUT:
				// USER START (Optionally insert code for reacting on notification message)
				// USER END
				break;
				// USER START (Optionally insert additional code for further notification handling)
				// USER END
			}
			break;
			// USER START (Optionally insert additional code for further Ids)
			// USER END
		}
		break;
		// USER START (Optionally insert additional message handling)
		// USER END
	default :
		WM_DefaultProc(pMsg);
		break;
	}
	valsChangedOld = masterClock.guiVars->valsChanged;
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateWindow
*/

WM_HWIN CreateTimeSetupWindow(void) {
	WM_HWIN hWin;

	hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
	masterClock.handles->hTimeSetupMenu = hWin;
	WM_SetCallback(WM_GetDialogItem(hWin, ID_BUTTON_HOURplus), _cbArrowUpButton);
	WM_SetCallback(WM_GetDialogItem(hWin, ID_BUTTON_MINplus), _cbArrowUpButton);
	WM_SetCallback(WM_GetDialogItem(hWin, ID_BUTTON_SECplus), _cbArrowUpButton);
	WM_SetCallback(WM_GetDialogItem(hWin, ID_BUTTON_HOURminus), _cbArrowDownButton);
	WM_SetCallback(WM_GetDialogItem(hWin, ID_BUTTON_MINminus), _cbArrowDownButton);
	WM_SetCallback(WM_GetDialogItem(hWin, ID_BUTTON_SECminus), _cbArrowDownButton);
	WM_SetCallback(WM_GetDialogItem(hWin, ID_BUTTON_ENTER), _cbEnterButton);

	return hWin;
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
